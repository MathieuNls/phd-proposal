\documentclass[11pt,a4paper, cuthesis]{report}
% \documentstyle{}


\usepackage{pgfgantt}

\usepackage{cuthesis}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}%
\usepackage{multirow}
\usepackage{algorithm2e}
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{xcolor}  % Coloured text etc.
\usepackage{hyperref}
\usepackage{listings}
\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\usepackage{todonotes}

\author{Mathieu Nayrolles}
\title{Pragmatic Software Maintenace: \\ Tool and technics to support software maintenance at commit-time.}

\titleOfPhDAuthor{Mr.}          % or Ms., Mrs., Miss, etc. (only for PhD's)
\PhD                            % Masters by default
\dept{Electrical \& Computer Engineering}        %   default is Comp.Sci.
%\cosupervisor                   % if you also have a co-supervisor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}


\begin{abstract}

  The maintenance and evolution of complex software systems account for more than 70\% software's life cycle.
  More than two decades of research have been conducted to improve our knowledge of these processes in terms of issue triaging, issue prediction, duplicate issue detection, issue reproduction and changes prediction.
  This research gave meaning to the millions of issues that can be found in project and revision management systems.
  Context-aware IDE and think tank in open source architecture, openned the path to approaches that support developers during their programming sessions by leveraging past knowledge and architectures.

  However, these techniques are still not broadly adopted by praticionners in large software companies.
  The main problem is the lack of actionable inteligence.
  Indeed, such systems tend to be seen as black boxes that yield false positive by end-users.
  Moreover, actions to resolve an identified problem can be hard to identify or to apply.

  In this research proposal, we present four approaches: (a) an online bug-fix search engine and API ({\tt BUMPER}, Bug MetarePository for dEveloper and Researcher), (b) an approach to automatically reproduce bug submitted to bug-report systems ({\tt JCHARMING}, Java CrasH Automatic Reproduction by directed Model checkING), (c) a recommendation system to propose the right auto-completion at the right time using actionnable inteligence ({\tt RESEMBLE}, REcommendation System based on cochangE Mining at Block LEvel) and, finally, (d) an approach to prevent bug insertion at commit-time by leveraging decade of open-source history ({\tt BIANCA}, Bug Insertion ANticipation by Clone Analysis at commit time).
  We also propose a taxonomy of bugs.
  When combined into {\tt pErICOPE} (Ecosystem Improve source COde during Programming session with real-time mining of common knowlEdge), these tools (i) provide the possibility to search related software artifacts using natural language, (ii) accurately reproduce field-crash in lab environment, (iii) recommend improvement or completion of block of code under edition and (iv) prevent the introduction of issues at commit time.

  This proposal develops these ideas while highlighting remaining issues and the PhD schedule.
\end{abstract}

\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Body of Thesis goes here.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\include{introduction}
\include{relworks}
\include{methodology/methodology}

\chapter{Reflection on pragmatic software maintenance}

Architects, the ones that design buildings --- where mistakes cost lives --- spend at least five years at school and possibly their whole carriers to study, understand and reproduce great designs made by great architects.
Software architects, however, begin in programing 101 by displaying the famous ``{\tt Hello World}'' statement and exponentially increase the complexity of their programs over their years of study and work.
At some point, they will earn the title of software architect (or technical leader) because they have designed, maintained and evolved {\it enough} programs to be trustworthy on the matter.
However, unlike building architects, they have to learn how to recognize, analyze and reproduce great architectural choices by themselves in addition of their day to day work.
Of course, software developers do learn good practices such as design patterns \cite{Gamma2008} but in a very few occasions they will be presented with a state-of-the-art program built by great developers (Amy Brown {\it et al.} propose exactly that in their books \cite{chansler2011architecture, AmyBrown2012, Armstrong2013}).

While our research is not about reforming how programming classes are taught, we still want to ease the access to this knowledge for developers during their programming sessions in order to ship better programs.

We shift the focus from merely mining revision and issue management system, where knowledge of great developers lies, to integrate them in their rightful place: as the keystone of software development and evolution activities.
Extracting the ground truth from repositories helped engineers and practitioners to be better at building softwares as they know, for example, {\it how long it will take to fix a bug} \cite{Weiss2007}, {\it what makes a good bug report} \cite{Bettenburg2008} or {\it how to fix long-lived bugs} \cite{Saha2014}.
Using these discoveries, tools can be created, on a per organization basis, to fit particular requirements such as programming languages, development processes or particular threshold. If we want to truthfully and deeply modify the software engineering landscape to have better softwares in terms of quality, maintainability and availability, we need to provide this information during the development, maintenance and evolution processes according to a specific context in an easy, reliable, actionable, free way.

If we look back at the history of software engineering, the increase of processors' speed and decrease of their price allowed one to have a compiler on its own machine rather than sending one's code to the mainframe and receive compilation errors hours (days) later. This allowed, among other factors, the democratization of software engineering as {\it everyone}, belonging to a major organization or not, became able to build code. We believe that, it is now time to allow developers, engineering and practitioners, regardless of their programming language and contextual environment, not only to write and build code but to write and built qualitative, robust, resilient, easy to maintain and to fix code. What better way to do so than to {\it stand on the shoulder of giants} by having access to all the open sources repositories, including but not limited to, issues, tasks, bug fixes, patches, comments, good practices break down to the right level and provided at the right time during day to day programming sessions?

We believe that the {\it right} times for distilling this information are when a developer version its code.

\include{plan}
\include{conclusion}


\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{library, russel}  %place your .bib files here
\bibliographystyle{alpha}                   %the bibliography style to use

\end{document}
